package eapcpm;
import java.util.*;
import java.io.*;


class InputReader{
    public BufferedReader reader;
    public StringTokenizer tokenizer;
    public InputReader(InputStream stream){
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenizer = null;
    }
    
    public String next(){
        while(tokenizer == null || !tokenizer.hasMoreTokens()){
            try{
                tokenizer = new StringTokenizer(reader.readLine());
            } catch(IOException e){
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }
    public int nextInt(){
        return Integer.parseInt(next());
    }
}

public class Eapcpm {
    public static int row;
    public static int column;
    public static int[][][] Tabuleiro;
    public static int[][] PieceArray;
    public static HashMap<int[],ArrayList<int[]>> compatibleKeys;
    
    static PrintWriter out = new PrintWriter(System.out);
        
    static void printPieces(){
        
        for(int i = 0; i<Tabuleiro.length; i++){
            for(int j = 0; j<Tabuleiro[0].length; j++){
                
                out.print( Tabuleiro[i][j][0] + " " + Tabuleiro[i][j][1]);
                
                if(j < Tabuleiro[0].length-1){
                    out.print("  ");
                }
   
            }
            out.println();
            for(int j = 0; j<Tabuleiro[0].length; j++){

                out.print( Tabuleiro[i][j][3] + " " + Tabuleiro[i][j][2]);
                if(j < Tabuleiro[0].length-1){
                   out.print("  ");
                } 
            }
            out.println();

            if(i < Tabuleiro.length-1){
                out.print("\n");
            }
        }
        
    }
    
//    static ArrayList<int[]> findCornersComp(int one, int two, int three){
//        int[] key = new int [3];
//        key[0] = one;
//        key[1] = two;
//        key[2] = three;
//    }
    static ArrayList<int[]> findCompatibles(int one, int two, boolean cima){
        int[] key = new int[2];
        key[0] = one;
        key[1] = two;
//        System.out.println("Looking for a piece compatible with: " + key[0] + " " + key[1] + " in " + cima);
        boolean exists = false;
        for (int[] compatibleKey : compatibleKeys.keySet()) {
            if(Arrays.equals(key, compatibleKey)){
                out.println("AAAAAAAAAAAAAAAAHHHHHHHHHHHHHHHHHHHHHHH");
    //                            System.out.println(Arrays.toString(temp2));
    //                            System.out.println(Arrays.toString(tempCompatible21));

                return compatibleKeys.get(compatibleKey);
            }
        }
        
            ArrayList<int[]> arrayFinal = new ArrayList<>();
            for(int i = 1; i<PieceArray.length; i++){
//                System.out.println("Peca: " + i + "tem: " + PieceArray[i][4]);
                int[] temp = PieceArray[i];
                for(int j = 0; j < 4; j++){
                    
                    
//                    System.out.println("Comparing with: \n" + Arrays.toString(temp));

                    if((key[0] == temp[0]) && (key[1] == temp[3])){
                        int[] tempArray = new int[2];
//                        System.out.println("Added!1");
                        tempArray[0] = i;
                        if(cima){
//                            System.out.println("firstC");
                            tempArray[1] = j;
                            tempArray[1]++;
                            
                            if(tempArray[1] > 3){
                                
                                tempArray[1] = 0;
                            }
//                            System.out.println("normal " + tempArray[1]);
                        }
                        else{
//                            System.out.println("normal " + j);
                            tempArray[1] = j;
                        }
                        
                        arrayFinal.add(tempArray);
                    }
                    rotatePiece(temp);
                }
                
                
            }
            compatibleKeys.put(key, arrayFinal);
            
            return compatibleKeys.get(key);
        
    }
    
    /*
    
    numRots esta entre 1 e 4
    
    */
    static void rotatePiece(int[] piece){
        int temp;
        temp = piece[0];
        piece[0] = piece[3];
        piece[3] = piece[2];
        piece[2] = piece[1];
        piece[1] = temp;
        
        
    }
    static int ComparePieces(int LastR, int LastC) {

        
        

        if((LastR == row-1) && (LastC == column-1)){
           
            return 1;
        }
        else if(LastC == column-1){
           
            LastC = 0;
            LastR+=1;
        }
        else{
            LastC++;
        }

        if (LastR == 0) {

            ArrayList<int[]> tempCompatible = findCompatibles(Tabuleiro[LastR][LastC-1][1],Tabuleiro[LastR][LastC-1][2],false);

            for (int i = 0; i<tempCompatible.size();i++) {
                
                int[] AllPiece = PieceArray[tempCompatible.get(i)[0]];
                int[] temp = new int[5];
                System.arraycopy(AllPiece, 0, temp, 0, AllPiece.length);
               

                if(AllPiece[4] == 0){
                    for(int rot = 0; rot<tempCompatible.get(i)[1]; rot++){
                        rotatePiece(temp);
                    }
                    
                    if((Tabuleiro[LastR][LastC-1][1] == temp[0]) && (Tabuleiro[LastR][LastC-1][2] == temp[3])){
                        Tabuleiro[LastR][LastC] = temp;


                        AllPiece[4] = 1;



                        int resultado = ComparePieces(LastR, LastC);

                        if(resultado == 1){
                            return 1;
                        }
                        else{
                            Tabuleiro[LastR][LastC] = null;
                            AllPiece[4] = 0;

                        }
                    }
                    
                    

                       
                    
                }
                //AllPiece = null;
            }
        }
        else{

            ArrayList<int[]> tempCompatible;
            if(LastC == 0){

                
                tempCompatible = findCompatibles(Tabuleiro[LastR-1][0][2],Tabuleiro[LastR-1][0][3],true);
                for(int i = 0; i<tempCompatible.size();i++){
                
                int[] AllPiece = PieceArray[tempCompatible.get(i)[0]];
                int[] temp = new int[5];
                System.arraycopy(AllPiece,0,temp,0,AllPiece.length);

                if(AllPiece[4] == 0){
                    for(int rot = 0; rot<tempCompatible.get(i)[1]; rot++){
                        rotatePiece(temp);
                    }
                    
                    
                    if((Tabuleiro[LastR-1][LastC][2] == temp[1]) && (Tabuleiro[LastR-1][LastC][3] == temp[0])){
                        Tabuleiro[LastR][LastC] = temp;

                        AllPiece[4] = 1;


                        int resultado = ComparePieces(LastR, LastC);

                        if(resultado == 1){
                            return 1;
                        }
                        else{
                            Tabuleiro[LastR][LastC] = null;
                            AllPiece[4] = 0;

                        }
                        

                       
                    }
                      
                }
                }

            }
            else{

                ArrayList<int[]>tempCompatible2 = findCompatibles(Tabuleiro[LastR-1][LastC][2],Tabuleiro[LastR-1][LastC][3],true);
                tempCompatible = findCompatibles(Tabuleiro[LastR][LastC-1][1],Tabuleiro[LastR][LastC-1][2],false);
                
              
            
            
            for(int i = 0; i<tempCompatible.size();i++){
                int[] temp2 = tempCompatible.get(i);
                boolean exists = false;
                    for (int[] tempCompatible21 : tempCompatible2) {
                        if(Arrays.equals(temp2, tempCompatible21)){
//                            System.out.println(Arrays.toString(temp2));
//                            System.out.println(Arrays.toString(tempCompatible21));
                            exists = true;
                            break;
                        }
                    }
                if(exists){
                    //out.println("aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
                    int[] AllPiece = PieceArray[tempCompatible.get(i)[0]];
                    int[] temp = new int[5];
                    System.arraycopy(AllPiece,0,temp,0,AllPiece.length);
                    if(AllPiece[4] == 0){
                    for(int rot = 0; rot<tempCompatible.get(i)[1]; rot++){
                        rotatePiece(temp);
                    }
                    
                    
                    if((Tabuleiro[LastR-1][LastC][2] == temp[1]) && (Tabuleiro[LastR-1][LastC][3] == temp[0])){
                        if((Tabuleiro[LastR][LastC-1][1] == temp[0]) && (Tabuleiro[LastR][LastC-1][2] == temp[3])){
                            Tabuleiro[LastR][LastC] = temp;
                            AllPiece[4] = 1;
                            int resultado = ComparePieces(LastR, LastC);

                            if(resultado == 1){
                                return 1;
                            }
                            else{
                                Tabuleiro[LastR][LastC] = null;
                                AllPiece[4] = 0;

                            }
                        }
                    }
                      
                }
                }
                else{
//                    System.out.println("uauauaua"); 
                }
                

                
            }
            }
        }
        return 0;
        
       
    }
    
    public static void main(String[] args) {
        
        InputReader in = new InputReader(System.in);
        
        
        
        
        int tries = in.nextInt();
        

        for (int i = 0; i < tries; i++) {
            compatibleKeys = new HashMap<>();
            int N = 0,R = 0,C = 0;
        
            
        
            int[] numeros = new int[999];
            
            
            
            try {

                N = in.nextInt();
                

                R = in.nextInt();
                C = in.nextInt();
                
                if(N == (R*C)){
                }else{
                    out.println("impossible puzzle!");
                    break;
                }
                PieceArray = new int[N][5];
            } catch (NumberFormatException ex) {
            }

            for (int j = 0; j < N; j++) {
                
                
                try {
                    for(int num = 0; num<4; num++){
                        PieceArray[j][num] = in.nextInt();
                        numeros[PieceArray[j][num]]+=1;
                    }
                    PieceArray[j][4] = 0;  
                } catch (NumberFormatException ex) {
                }
            }
            int contaImpares = 0;
            for(int c = 0; c<numeros.length; c++){
                if ( (numeros[c]%2) == 0 ) { 
                } else { 
                    
                    contaImpares++;                     
                }  
            }
            if (contaImpares>4) { 
                        out.println("impossible puzzle!");
                }
            else{
                int[] FirstPiece = PieceArray[0];
          
                Tabuleiro = new int[R][C][5];
                
                Tabuleiro[0][0] = FirstPiece;
                row = Tabuleiro.length;
                column = Tabuleiro[0].length;
                FirstPiece[4] = 1;
                int LastPieceR = 0; 
                int LastPieceC = 0;


                if(ComparePieces(LastPieceR,LastPieceC) == 1){
                    printPieces();
                }
                else{
                    out.println("impossible puzzle!");
                }
                Tabuleiro = null;
                compatibleKeys.clear();
                PieceArray = null;


            }
        }
        out.close();
    }
    
}